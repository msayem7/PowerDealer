SMALL / LIGHTWEIGHT SOFTWARE GUIDELINE (With Error Handling & Logging)

PURPOSE

This guideline is for MVPs, admin panels, internal tools, and
prototypes. The focus is SPEED + CLARITY, while still keeping
user-friendly error handling and production-safe logging.

Do not over-engineer, but do not ignore reliability.

TECH STACK

Backend: Django + Django REST Framework
Frontend: Vue 3 + Pinia
Auth: Simple JWT or Session
Testing: Minimal but meaningful

  -------------------
  BACKEND GUIDELINE
  -------------------

PROJECT STRUCTURE

app/ models.py serializers.py views.py urls.py

Keep structure flat so developers can move fast.

  --------
  MODELS
  --------

-   Keep fields minimal.
-   Avoid premature abstractions.
-   Only add relations when business requires them.
-   Add created_at / updated_at when data matters.

Reason: Small apps grow. These fields help later debugging.

  -------------
  SERIALIZERS
  -------------

-   Use ModelSerializer.
-   Validate only what is necessary.
-   Return clear error messages.

Example: If email already exists, return: “This email is already
registered.”

Reason: Errors should be readable by humans, not developers only.

  -------
  VIEWS
  -------

-   Use APIView.
-   Keep logic readable.
-   Avoid large functions.
-   Catch predictable exceptions.

Example behavior: - Validation error → 400 - Not found → 404 -
Permission error → 403 - Server error → 500

Reason: Correct HTTP codes help frontend show correct messages.

  --------------------------
  ERROR HANDLING (Backend)
  --------------------------

Always return a consistent format:

{ success: false, message: “Something went wrong”, errors: {} }

Rules:

-   Do NOT expose stack traces to users.
-   Log technical details internally.
-   Send friendly messages to frontend.

Examples:

Bad: “KeyError at line 55”

Good: “We couldn’t process your request right now.”

Use DRF custom exception handler if possible.

Reason: Users need clarity, developers need logs.

  -------------------
  LOGGING (Backend)
  -------------------

Enable logging in production:

-   Log errors
-   Log important actions
-   Log unexpected behavior

Log levels:

INFO → normal operations
WARNING → suspicious but working
ERROR → failed operation
CRITICAL→ system crash

Log examples:

-   User login failed
-   Payment creation failed
-   API timeout

Never log:

-   Passwords
-   Tokens
-   Card numbers

Reason: Logs are for developers, not attackers.

  --------------------
  FRONTEND GUIDELINE
  --------------------

PROJECT STRUCTURE

src/ api/ stores/ views/ components/

Keep layout simple and predictable.

  -----------
  API LAYER
  -----------

Use one axios instance.

Handle:

-   Network errors
-   401 unauthorized
-   500 server errors

Example behavior:

-   Network error → “Server not reachable”
-   401 → “Please login again”
-   500 → “Something went wrong”

Reason: Frontend must translate technical errors into human language.

  --------------
  PINIA STORES
  --------------

Stores manage:

-   data
-   loading
-   error

Example state:

{ list: [], loading: false, error: null }

Rules:

-   Always reset error before request.
-   Catch API errors.
-   Store friendly message, not raw error.

Reason: UI should never show raw backend messages.

  ------------------------
  USER FRIENDLY MESSAGES
  ------------------------

Always speak like a human:

Bad: “Invalid payload”

Good: “Some information is missing. Please check and try again.”

Bad: “Unauthorized”

Good: “Your session expired. Please login again.”

Reason: Users are not developers.

  ---------------------------------
  GLOBAL ERROR HANDLER (Frontend)
  ---------------------------------

Create one handler to:

-   Catch axios errors
-   Map status to messages
-   Redirect on auth failure

Example mapping:

400 → “Please check your input.”
401 → “Login required.”
403 → “You don’t have permission.”
404 → “Not found.”
500 → “Server problem. Try later.”

Reason: One place to control all errors.

  --------------------
  LOGGING (Frontend)
  --------------------

Log:

-   API failures
-   UI crashes
-   Unexpected behavior

In development: - console.error

In production: - send logs to server endpoint

Never log: - passwords - tokens - private user data

Reason: Frontend logs help debugging real users.

  ---------
  TESTING
  ---------

Test at least:

-   Critical APIs
-   Main user flows
-   Error scenarios

Example:

-   Login failure
-   Network down
-   Invalid input

Reason: Most bugs appear in error cases.

  ------
  GOAL
  ------

This guideline ensures:

-   Fast development
-   Friendly user experience
-   Safe production logging
-   No over-engineering

Perfect for MVPs and small systems that still behave professionally.
